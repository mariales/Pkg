(self.webpackChunkapp_studio_enterprise_schema_view=self.webpackChunkapp_studio_enterprise_schema_view||[]).push([[57985],{57985:(Fe,k,p)=>{p.r(k),p.d(k,{ComponentFixture:()=>S,ComponentFixtureAutoDetect:()=>U,ComponentFixtureNoNgZone:()=>N,DeferBlockBehavior:()=>r.\u0275DeferBlockBehavior,DeferBlockFixture:()=>E,DeferBlockState:()=>r.\u0275DeferBlockState,InjectSetupWrapper:()=>z,TestBed:()=>V,TestComponentRenderer:()=>D,__core_private_testing_placeholder__:()=>ke,async:()=>X,discardPeriodicTasks:()=>de,fakeAsync:()=>ce,flush:()=>ae,flushMicrotasks:()=>ue,getTestBed:()=>Re,inject:()=>$,resetFakeAsyncZone:()=>se,tick:()=>le,waitForAsync:()=>F,withModule:()=>Pe,\u0275MetadataOverrider:()=>B});var v=p(73308),r=p(59131),J=p(62278),q=p(36486),Y=p(21533);/**
 * @license Angular v17.3.12
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */function F(s){const e=typeof Zone<"u"?Zone:null;if(!e)return function(){return Promise.reject("Zone is needed for the waitForAsync() test helper but could not be found. Please make sure that your environment includes zone.js")};const t=e&&e[e.__symbol__("asyncTest")];return typeof t=="function"?t(s):function(){return Promise.reject("zone-testing.js is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/testing")}}function X(s){return F(s)}class E{constructor(e,t){this.block=e,this.componentFixture=t}render(e){var t=this;return(0,v.A)(function*(){if(!ee(e,t.block)){const o=te(e);throw new Error(`Tried to render this defer block in the \`${o}\` state, but there was no @${o.toLowerCase()} block defined in a template.`)}e===r.\u0275DeferBlockState.Complete&&(yield(0,r.\u0275triggerResourceLoading)(t.block.tDetails,t.block.lView,t.block.tNode)),(0,r.\u0275renderDeferBlockState)(e,t.block.tNode,t.block.lContainer,!0),t.componentFixture.detectChanges()})()}getDeferBlocks(){const e=[],t=[];if(this.block.lContainer.length>=r.\u0275CONTAINER_HEADER_OFFSET){const n=this.block.lContainer[r.\u0275CONTAINER_HEADER_OFFSET];(0,r.\u0275getDeferBlocks)(n,e);for(const o of e)t.push(new E(o,this.componentFixture))}return Promise.resolve(t)}}function ee(s,e){switch(s){case r.\u0275DeferBlockState.Placeholder:return e.tDetails.placeholderTmplIndex!==null;case r.\u0275DeferBlockState.Loading:return e.tDetails.loadingTmplIndex!==null;case r.\u0275DeferBlockState.Error:return e.tDetails.errorTmplIndex!==null;case r.\u0275DeferBlockState.Complete:return!0;default:return!1}}function te(s){switch(s){case r.\u0275DeferBlockState.Placeholder:return"Placeholder";case r.\u0275DeferBlockState.Loading:return"Loading";case r.\u0275DeferBlockState.Error:return"Error";default:return"Main"}}const I=!0,b=!1,j=!1,_=r.\u0275DeferBlockBehavior.Playthrough;class D{insertRootElement(e){}removeAllRootElements(){}}const U=new r.InjectionToken("ComponentFixtureAutoDetect"),ne=new r.InjectionToken("AllowDetectChangesAndAcknowledgeItCanHideApplicationBugs"),N=new r.InjectionToken("ComponentFixtureNoNgZone");class S{constructor(e){this.componentRef=e,this._isDestroyed=!1,this._noZoneOptionIsSet=(0,r.inject)(N,{optional:!0}),this._ngZone=this._noZoneOptionIsSet?new r.\u0275NoopNgZone:(0,r.inject)(r.NgZone),this._effectRunner=(0,r.inject)(r.\u0275EffectScheduler),this._appRef=(0,r.inject)(r.ApplicationRef),this._testAppRef=this._appRef,this.ngZone=this._noZoneOptionIsSet?null:this._ngZone,this.changeDetectorRef=e.changeDetectorRef,this.elementRef=e.location,this.debugElement=(0,r.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=e.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=e}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}getDeferBlocks(){const e=[],t=this.componentRef.hostView._lView;(0,r.\u0275getDeferBlocks)(t,e);const n=[];for(const o of e)n.push(new E(o,this));return Promise.resolve(n)}_getRenderer(){return this._renderer===void 0&&(this._renderer=this.componentRef.injector.get(r.RendererFactory2,null)),this._renderer}whenRenderingDone(){const e=this._getRenderer();return e&&e.whenRenderingDone?e.whenRenderingDone():this.whenStable()}destroy(){this._isDestroyed||(this.componentRef.destroy(),this._isDestroyed=!0)}}class re extends S{constructor(){super(...arguments),this.disableDetectChangesError=(0,r.inject)(ne,{optional:!0})??!1,this.pendingTasks=(0,r.inject)(r.\u0275PendingTasks)}initialize(){this._appRef.attachView(this.componentRef.hostView)}detectChanges(e=!0){if(this.disableDetectChangesError){if(!e)throw new Error("Cannot disable `checkNoChanges` in this configuration. Use `fixture.componentRef.hostView.changeDetectorRef.detectChanges()` instead.")}else throw new Error("Do not use `detectChanges` directly when using zoneless change detection. Instead, wait for the next render or `fixture.whenStable`.");this._effectRunner.flush(),this._appRef.tick(),this._effectRunner.flush()}isStable(){return!this.pendingTasks.hasPendingTasks.value}whenStable(){return this.isStable()?Promise.resolve(!1):this._appRef.isStable.pipe((0,q.first)(e=>e)).toPromise().then(()=>!0)}autoDetectChanges(e){throw new Error("Cannot call autoDetectChanges when using change detection scheduling.")}}class oe extends S{constructor(){super(...arguments),this._subscriptions=new J.Subscription,this._autoDetect=(0,r.inject)(U,{optional:!0})??!1,this._isStable=!0,this._promise=null,this._resolve=null,this.afterTickSubscription=void 0,this.beforeRenderSubscription=void 0}initialize(){this._ngZone.runOutsideAngular(()=>{this._subscriptions.add(this._ngZone.onUnstable.subscribe({next:()=>{this._isStable=!1}})),this._subscriptions.add(this._ngZone.onMicrotaskEmpty.subscribe({next:()=>{this._autoDetect&&this.detectChanges(!0)}})),this._subscriptions.add(this._ngZone.onStable.subscribe({next:()=>{this._isStable=!0,this._promise!==null&&queueMicrotask(()=>{this._ngZone.hasPendingMacrotasks||this._promise!==null&&(this._resolve(!0),this._resolve=null,this._promise=null)})}})),this._subscriptions.add(this._ngZone.onError.subscribe({next:e=>{throw e}}))})}detectChanges(e=!0){this._effectRunner.flush(),this._ngZone.run(()=>{this.changeDetectorRef.detectChanges(),e&&this.checkNoChanges()}),this._effectRunner.flush()}isStable(){return this._isStable&&!this._ngZone.hasPendingMacrotasks}whenStable(){return this.isStable()?Promise.resolve(!1):this._promise!==null?this._promise:(this._promise=new Promise(e=>{this._resolve=e}),this._promise)}autoDetectChanges(e=!0){if(this._noZoneOptionIsSet)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.");this._autoDetect=e,this.detectChanges()}destroy(){this._subscriptions.unsubscribe(),super.destroy()}}const A=typeof Zone<"u"?Zone:null,d=A&&A[A.__symbol__("fakeAsyncTest")],m=`zone-testing.js is needed for the fakeAsync() test helper but could not be found.
        Please make sure that your environment includes zone.js/testing`;function se(){if(d)return d.resetFakeAsyncZone();throw new Error(m)}function ie(){d&&d.resetFakeAsyncZone()}function ce(s){if(d)return d.fakeAsync(s);throw new Error(m)}function le(s=0,e={processNewMacroTasksSynchronously:!0}){if(d)return d.tick(s,e);throw new Error(m)}function ae(s){if(d)return d.flush(s);throw new Error(m)}function de(){if(d)return d.discardPeriodicTasks();throw new Error(m)}function ue(){if(d)return d.flushMicrotasks();throw new Error(m)}let he=0;class B{constructor(){this._references=new Map}overrideMetadata(e,t,n){const o={};if(t&&ge(t).forEach(i=>o[i]=t[i]),n.set){if(n.remove||n.add)throw new Error(`Cannot set and add/remove ${(0,r.\u0275stringify)(e)} at the same time!`);ve(o,n.set)}return n.remove&&pe(o,n.remove,this._references),n.add&&fe(o,n.add),new e(o)}}function pe(s,e,t){const n=new Set;for(const o in e){const i=e[o];Array.isArray(i)?i.forEach(a=>{n.add(C(o,a,t))}):n.add(C(o,i,t))}for(const o in s){const i=s[o];Array.isArray(i)?s[o]=i.filter(a=>!n.has(C(o,a,t))):n.has(C(o,i,t))&&(s[o]=void 0)}}function fe(s,e){for(const t in e){const n=e[t],o=s[t];o!=null&&Array.isArray(o)?s[t]=o.concat(n):s[t]=n}}function ve(s,e){for(const t in e)s[t]=e[t]}function C(s,e,t){let n=0;const o=new Map;return`${s}:${JSON.stringify(e,(a,c)=>c!==null&&typeof c=="object"?o.has(c)?o.get(c):(o.set(c,`\u0275obj#${n++}`),c):(typeof c=="function"&&(c=me(c,t)),c))}`}function me(s,e){let t=e.get(s);return t||(t=`${(0,r.\u0275stringify)(s)}${he++}`,e.set(s,t)),t}function ge(s){const e=[];Object.keys(s).forEach(n=>{n.startsWith("_")||e.push(n)});let t=s;for(;t=Object.getPrototypeOf(t);)Object.keys(t).forEach(n=>{const o=Object.getOwnPropertyDescriptor(t,n);!n.startsWith("_")&&o&&"get"in o&&e.push(n)});return e}const _e=new r.\u0275ReflectionCapabilities;class M{constructor(){this.overrides=new Map,this.resolved=new Map}addOverride(e,t){const n=this.overrides.get(e)||[];n.push(t),this.overrides.set(e,n),this.resolved.delete(e)}setOverrides(e){this.overrides.clear(),e.forEach(([t,n])=>{this.addOverride(t,n)})}getAnnotation(e){const t=_e.annotations(e);for(let n=t.length-1;n>=0;n--){const o=t[n];if(o instanceof r.Directive||o instanceof r.Component||o instanceof r.Pipe||o instanceof r.NgModule)return o instanceof this.type?o:null}return null}resolve(e){let t=this.resolved.get(e)||null;if(!t){if(t=this.getAnnotation(e),t){const n=this.overrides.get(e);if(n){const o=new B;n.forEach(i=>{t=o.overrideMetadata(this.type,t,i)})}}this.resolved.set(e,t)}return t}}class Ee extends M{get type(){return r.Directive}}class Ce extends M{get type(){return r.Component}}class Me extends M{get type(){return r.Pipe}}class Oe extends M{get type(){return r.NgModule}}var f;(function(s){s[s.DECLARATION=0]="DECLARATION",s[s.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"})(f||(f={}));function we(s){return s===f.DECLARATION||s===f.OVERRIDE_TEMPLATE}function x(s,e,t){s.forEach(n=>{if(!(0,r.\u0275getAsyncClassMetadataFn)(n)){const o=e.resolve(n);if(o&&o.standalone)throw new Error((0,r.\u0275generateStandaloneInDeclarationsError)(n,t))}})}class L{constructor(e,t){this.platform=e,this.additionalModuleTypes=t,this.originalComponentResolutionQueue=null,this.declarations=[],this.imports=[],this.providers=[],this.schemas=[],this.pendingComponents=new Set,this.pendingDirectives=new Set,this.pendingPipes=new Set,this.componentsWithAsyncMetadata=new Set,this.seenComponents=new Set,this.seenDirectives=new Set,this.overriddenModules=new Set,this.existingComponentStyles=new Map,this.resolvers=Te(),this.componentToModuleScope=new Map,this.initialNgDefs=new Map,this.defCleanupOps=[],this._injector=null,this.compilerProviders=null,this.providerOverrides=[],this.rootProviderOverrides=[],this.providerOverridesByModule=new Map,this.providerOverridesByToken=new Map,this.scopesWithOverriddenProviders=new Set,this.testModuleRef=null,this.deferBlockBehavior=_;class n{}this.testModuleType=n}setCompilerProviders(e){this.compilerProviders=e,this._injector=null}configureTestingModule(e){e.declarations!==void 0&&(x(e.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(e.declarations,f.DECLARATION),this.declarations.push(...e.declarations)),e.imports!==void 0&&(this.queueTypesFromModulesArray(e.imports),this.imports.push(...e.imports)),e.providers!==void 0&&this.providers.push(...e.providers),e.schemas!==void 0&&this.schemas.push(...e.schemas),this.deferBlockBehavior=e.deferBlockBehavior??_}overrideModule(e,t){r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT&&r.\u0275depsTracker.clearScopeCacheFor(e),this.overriddenModules.add(e),this.resolvers.module.addOverride(e,t);const n=this.resolvers.module.resolve(e);if(n===null)throw y(e.name,"NgModule");this.recompileNgModule(e,n),this.queueTypesFromModulesArray([e])}overrideComponent(e,t){this.verifyNoStandaloneFlagOverrides(e,t),this.resolvers.component.addOverride(e,t),this.pendingComponents.add(e),this.maybeRegisterComponentWithAsyncMetadata(e)}overrideDirective(e,t){this.verifyNoStandaloneFlagOverrides(e,t),this.resolvers.directive.addOverride(e,t),this.pendingDirectives.add(e)}overridePipe(e,t){this.verifyNoStandaloneFlagOverrides(e,t),this.resolvers.pipe.addOverride(e,t),this.pendingPipes.add(e)}verifyNoStandaloneFlagOverrides(e,t){if(t.add?.hasOwnProperty("standalone")||t.set?.hasOwnProperty("standalone")||t.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${e.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(e,t){let n;t.useFactory!==void 0?n={provide:e,useFactory:t.useFactory,deps:t.deps||[],multi:t.multi}:t.useValue!==void 0?n={provide:e,useValue:t.useValue,multi:t.multi}:n={provide:e};const o=typeof e!="string"?(0,r.\u0275getInjectableDef)(e):null,i=o===null?null:(0,r.resolveForwardRef)(o.providedIn);if((i==="root"?this.rootProviderOverrides:this.providerOverrides).push(n),this.providerOverridesByToken.set(e,n),o!==null&&i!==null&&typeof i!="string"){const c=this.providerOverridesByModule.get(i);c!==void 0?c.push(n):this.providerOverridesByModule.set(i,[n])}}overrideTemplateUsingTestingModule(e,t){const n=e[r.\u0275NG_COMP_DEF],o=()=>{const c=this.resolvers.component.resolve(e);return!!c.styleUrl||!!c.styleUrls?.length},i=!!n&&!(0,r.\u0275isComponentDefPendingResolution)(e)&&o(),a=i?{template:t,styles:[],styleUrls:[],styleUrl:void 0}:{template:t};this.overrideComponent(e,{set:a}),i&&n.styles&&n.styles.length>0&&this.existingComponentStyles.set(e,n.styles),this.componentToModuleScope.set(e,f.OVERRIDE_TEMPLATE)}resolvePendingComponentsWithAsyncMetadata(){var e=this;return(0,v.A)(function*(){if(e.componentsWithAsyncMetadata.size===0)return;const t=[];for(const i of e.componentsWithAsyncMetadata){const a=(0,r.\u0275getAsyncClassMetadataFn)(i);a&&t.push(a())}e.componentsWithAsyncMetadata.clear();const o=(yield Promise.all(t)).flat(2);e.queueTypesFromModulesArray(o);for(const i of o)e.applyProviderOverridesInScope(i)})()}compileComponents(){var e=this;return(0,v.A)(function*(){if(e.clearComponentResolutionQueue(),yield e.resolvePendingComponentsWithAsyncMetadata(),x(e.declarations,e.resolvers.component,'"TestBed.configureTestingModule" call'),e.compileTypesSync()){let n,o=i=>(n||(n=e.injector.get(Y.ResourceLoader)),Promise.resolve(n.get(i)));yield(0,r.\u0275resolveComponentResources)(o)}})()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const e=this.platform.injector;this.testModuleRef=new r.\u0275Render3NgModuleRef(this.testModuleType,e,[]),this.testModuleRef.injector.get(r.ApplicationInitStatus).runInitializers();const t=this.testModuleRef.injector.get(r.LOCALE_ID,r.\u0275DEFAULT_LOCALE_ID);return(0,r.\u0275setLocaleId)(t),this.testModuleRef}_compileNgModuleSync(e){this.queueTypesFromModulesArray([e]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(e),this.applyTransitiveScopes()}_compileNgModuleAsync(e){var t=this;return(0,v.A)(function*(){t.queueTypesFromModulesArray([e]),yield t.compileComponents(),t.applyProviderOverrides(),t.applyProviderOverridesInScope(e),t.applyTransitiveScopes()})()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(e){return h(e.\u0275mod.declarations).reduce((t,n)=>{const o=n.\u0275cmp;return o&&t.push(new r.\u0275Render3ComponentFactory(o,this.testModuleRef)),t},[])}compileTypesSync(){let e=!1;return this.pendingComponents.forEach(t=>{if((0,r.\u0275getAsyncClassMetadataFn)(t))throw new Error(`Component '${t.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);e=e||(0,r.\u0275isComponentDefPendingResolution)(t);const n=this.resolvers.component.resolve(t);if(n===null)throw y(t.name,"Component");this.maybeStoreNgDef(r.\u0275NG_COMP_DEF,t),r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT&&r.\u0275depsTracker.clearScopeCacheFor(t),(0,r.\u0275compileComponent)(t,n)}),this.pendingComponents.clear(),this.pendingDirectives.forEach(t=>{const n=this.resolvers.directive.resolve(t);if(n===null)throw y(t.name,"Directive");this.maybeStoreNgDef(r.\u0275NG_DIR_DEF,t),(0,r.\u0275compileDirective)(t,n)}),this.pendingDirectives.clear(),this.pendingPipes.forEach(t=>{const n=this.resolvers.pipe.resolve(t);if(n===null)throw y(t.name,"Pipe");this.maybeStoreNgDef(r.\u0275NG_PIPE_DEF,t),(0,r.\u0275compilePipe)(t,n)}),this.pendingPipes.clear(),e}applyTransitiveScopes(){if(this.overriddenModules.size>0){const n=this.testModuleType[r.\u0275NG_MOD_DEF],o=this.collectModulesAffectedByOverrides(n.imports);o.size>0&&o.forEach(i=>{r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT?r.\u0275depsTracker.clearScopeCacheFor(i):(this.storeFieldOfDefOnType(i,r.\u0275NG_MOD_DEF,"transitiveCompileScopes"),i[r.\u0275NG_MOD_DEF].transitiveCompileScopes=null)})}const e=new Map,t=n=>{if(!e.has(n)){const i=we(n)?this.testModuleType:n;e.set(n,(0,r.\u0275transitiveScopesFor)(i))}return e.get(n)};this.componentToModuleScope.forEach((n,o)=>{if(n!==null){const i=t(n);this.storeFieldOfDefOnType(o,r.\u0275NG_COMP_DEF,"directiveDefs"),this.storeFieldOfDefOnType(o,r.\u0275NG_COMP_DEF,"pipeDefs"),(0,r.\u0275patchComponentDefWithScope)(w(o),i)}this.storeFieldOfDefOnType(o,r.\u0275NG_COMP_DEF,"tView")}),this.componentToModuleScope.clear()}applyProviderOverrides(){const e=t=>n=>{const i=(t===r.\u0275NG_COMP_DEF?this.resolvers.component:this.resolvers.directive).resolve(n);this.hasProviderOverrides(i.providers)&&this.patchDefWithProviderOverrides(n,t)};this.seenComponents.forEach(e(r.\u0275NG_COMP_DEF)),this.seenDirectives.forEach(e(r.\u0275NG_DIR_DEF)),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(e){if(!(O(e)||ye(e))||this.scopesWithOverriddenProviders.has(e))return;this.scopesWithOverriddenProviders.add(e);const n=e[r.\u0275NG_INJ_DEF];if(this.providerOverridesByToken.size!==0)if(O(e)){const o=w(e),i=h(o.dependencies??[]);for(const a of i)this.applyProviderOverridesInScope(a)}else{const o=[...n.providers,...this.providerOverridesByModule.get(e)||[]];this.hasProviderOverrides(o)&&(this.maybeStoreNgDef(r.\u0275NG_INJ_DEF,e),this.storeFieldOfDefOnType(e,r.\u0275NG_INJ_DEF,"providers"),n.providers=this.getOverriddenProviders(o));const i=e[r.\u0275NG_MOD_DEF],a=h(i.imports);for(const c of a)this.applyProviderOverridesInScope(c);for(const c of R(n.imports))Z(c)&&(this.defCleanupOps.push({object:c,fieldName:"providers",originalValue:c.providers}),c.providers=this.getOverriddenProviders(c.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach((e,t)=>t[r.\u0275NG_COMP_DEF].styles=e),this.existingComponentStyles.clear()}queueTypeArray(e,t){for(const n of e)Array.isArray(n)?this.queueTypeArray(n,t):this.queueType(n,t)}recompileNgModule(e,t){this.maybeStoreNgDef(r.\u0275NG_MOD_DEF,e),this.maybeStoreNgDef(r.\u0275NG_INJ_DEF,e),(0,r.\u0275compileNgModuleDefs)(e,t)}maybeRegisterComponentWithAsyncMetadata(e){(0,r.\u0275getAsyncClassMetadataFn)(e)&&this.componentsWithAsyncMetadata.add(e)}queueType(e,t){if(this.maybeRegisterComponentWithAsyncMetadata(e),this.resolvers.component.resolve(e)){((0,r.\u0275isComponentDefPendingResolution)(e)||!e.hasOwnProperty(r.\u0275NG_COMP_DEF))&&this.pendingComponents.add(e),this.seenComponents.add(e),(!this.componentToModuleScope.has(e)||this.componentToModuleScope.get(e)===f.DECLARATION)&&this.componentToModuleScope.set(e,t);return}if(this.resolvers.directive.resolve(e)){e.hasOwnProperty(r.\u0275NG_DIR_DEF)||this.pendingDirectives.add(e),this.seenDirectives.add(e);return}if(this.resolvers.pipe.resolve(e)&&!e.hasOwnProperty(r.\u0275NG_PIPE_DEF)){this.pendingPipes.add(e);return}}queueTypesFromModulesArray(e){const t=new Set,n=o=>{for(const i of o)if(Array.isArray(i))n(i);else if(T(i)){const a=i.\u0275mod;if(t.has(a))continue;t.add(a),this.queueTypeArray(h(a.declarations),i),n(h(a.imports)),n(h(a.exports))}else if(Z(i))n([i.ngModule]);else if(O(i)){this.queueType(i,null);const a=w(i);if(t.has(a))continue;t.add(a),h(a.dependencies??[]).forEach(u=>{O(u)||T(u)?n([u]):this.queueType(u,null)})}};n(e)}collectModulesAffectedByOverrides(e){const t=new Set,n=new Set,o=(i,a)=>{for(const c of i)if(Array.isArray(c))o(c,a);else if(T(c)){if(t.has(c)){n.has(c)&&a.forEach(g=>n.add(g));continue}t.add(c),this.overriddenModules.has(c)&&a.forEach(g=>n.add(g));const u=c[r.\u0275NG_MOD_DEF];o(h(u.imports),a.concat(c))}};return o(e,[]),n}maybeStoreNgDef(e,t){this.initialNgDefs.has(t)||this.initialNgDefs.set(t,new Map);const n=this.initialNgDefs.get(t);if(!n.has(e)){const o=Object.getOwnPropertyDescriptor(t,e);n.set(e,o)}}storeFieldOfDefOnType(e,t,n){const o=e[t],i=o[n];this.defCleanupOps.push({object:o,fieldName:n,originalValue:i})}clearComponentResolutionQueue(){this.originalComponentResolutionQueue===null&&(this.originalComponentResolutionQueue=new Map),(0,r.\u0275clearResolutionOfComponentResourcesQueue)().forEach((e,t)=>this.originalComponentResolutionQueue.set(t,e))}restoreComponentResolutionQueue(){this.originalComponentResolutionQueue!==null&&((0,r.\u0275restoreComponentResolutionQueue)(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){G(this.defCleanupOps,e=>{e.object[e.fieldName]=e.originalValue}),this.initialNgDefs.forEach((e,t)=>{r.\u0275USE_RUNTIME_DEPS_TRACKER_FOR_JIT&&r.\u0275depsTracker.clearScopeCacheFor(t),e.forEach((n,o)=>{n?Object.defineProperty(t,o,n):delete t[o]})}),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,r.\u0275setLocaleId)(r.\u0275DEFAULT_LOCALE_ID)}compileTestModule(){class e{}(0,r.\u0275compileNgModuleDefs)(e,{providers:[...this.rootProviderOverrides]});const t=[(0,r.provideZoneChangeDetection)(),{provide:r.Compiler,useFactory:()=>new Se(this)},{provide:r.\u0275DEFER_BLOCK_CONFIG,useValue:{behavior:this.deferBlockBehavior}},...this.providers,...this.providerOverrides],n=[e,this.additionalModuleTypes,this.imports||[]];(0,r.\u0275compileNgModuleDefs)(this.testModuleType,{declarations:this.declarations,imports:n,schemas:this.schemas,providers:t},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(this._injector!==null)return this._injector;const e=[];return this.platform.injector.get(r.COMPILER_OPTIONS).forEach(n=>{n.providers&&e.push(n.providers)}),this.compilerProviders!==null&&e.push(...this.compilerProviders),this._injector=r.Injector.create({providers:e,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(e){const t=W(e);return this.providerOverridesByToken.get(t)||null}getProviderOverrides(e){return!e||!e.length||this.providerOverridesByToken.size===0?[]:R(P(e,t=>this.getSingleProviderOverrides(t)||[]))}getOverriddenProviders(e){if(!e||!e.length||this.providerOverridesByToken.size===0)return[];const t=P(e),n=this.getProviderOverrides(t),o=[...t,...n],i=[],a=new Set;return G(o,c=>{const u=W(c);this.providerOverridesByToken.has(u)?a.has(u)||(a.add(u),i.unshift({...c,multi:!1})):i.unshift(c)}),i}hasProviderOverrides(e){return this.getProviderOverrides(e).length>0}patchDefWithProviderOverrides(e,t){const n=e[t];if(n&&n.providersResolver){this.maybeStoreNgDef(t,e);const o=n.providersResolver,i=a=>this.getOverriddenProviders(a);this.storeFieldOfDefOnType(e,t,"providersResolver"),n.providersResolver=a=>o(a,i)}}}function Te(){return{module:new Oe,component:new Ce,directive:new Ee,pipe:new Me}}function O(s){return!!w(s)?.standalone}function w(s){return s.\u0275cmp??null}function T(s){return s.hasOwnProperty("\u0275mod")}function ye(s){return T(s)}function h(s){return s instanceof Function?s():s}function R(s){const e=[];return s.forEach(t=>{Array.isArray(t)?e.push(...R(t)):e.push(t)}),e}function De(s){return s}function P(s,e=De){const t=[];for(let n of s)(0,r.\u0275isEnvironmentProviders)(n)&&(n=n.\u0275providers),Array.isArray(n)?t.push(...P(n,e)):t.push(e(n));return t}function Ne(s,e){return s&&typeof s=="object"&&s[e]}function W(s){return Ne(s,"provide")||s}function Z(s){return s.hasOwnProperty("ngModule")}function G(s,e){for(let t=s.length-1;t>=0;t--)e(s[t],t)}function y(s,e){return new Error(`${s} class doesn't have @${e} decorator or is missing metadata.`)}class Se{constructor(e){this.testBed=e}compileModuleSync(e){return this.testBed._compileNgModuleSync(e),new r.\u0275NgModuleFactory(e)}compileModuleAsync(e){var t=this;return(0,v.A)(function*(){return yield t.testBed._compileNgModuleAsync(e),new r.\u0275NgModuleFactory(e)})()}compileModuleAndAllComponentsSync(e){const t=this.compileModuleSync(e),n=this.testBed._getComponentFactories(e);return new r.ModuleWithComponentFactories(t,n)}compileModuleAndAllComponentsAsync(e){var t=this;return(0,v.A)(function*(){const n=yield t.compileModuleAsync(e),o=t.testBed._getComponentFactories(e);return new r.ModuleWithComponentFactories(n,o)})()}clearCache(){}clearCacheFor(e){}getModuleId(e){const t=this.testBed._getModuleResolver().resolve(e);return t&&t.id||void 0}}let Ae=0;function Re(){return l.INSTANCE}class l{constructor(){this._instanceDeferBlockBehavior=_,this.platform=null,this.ngModule=null,this._compiler=null,this._testModuleRef=null,this._activeFixtures=[],this.globalCompilationChecked=!1}static{this._INSTANCE=null}static get INSTANCE(){return l._INSTANCE=l._INSTANCE||new l}static initTestEnvironment(e,t,n){const o=l.INSTANCE;return o.initTestEnvironment(e,t,n),o}static resetTestEnvironment(){l.INSTANCE.resetTestEnvironment()}static configureCompiler(e){return l.INSTANCE.configureCompiler(e)}static configureTestingModule(e){return l.INSTANCE.configureTestingModule(e)}static compileComponents(){return l.INSTANCE.compileComponents()}static overrideModule(e,t){return l.INSTANCE.overrideModule(e,t)}static overrideComponent(e,t){return l.INSTANCE.overrideComponent(e,t)}static overrideDirective(e,t){return l.INSTANCE.overrideDirective(e,t)}static overridePipe(e,t){return l.INSTANCE.overridePipe(e,t)}static overrideTemplate(e,t){return l.INSTANCE.overrideTemplate(e,t)}static overrideTemplateUsingTestingModule(e,t){return l.INSTANCE.overrideTemplateUsingTestingModule(e,t)}static overrideProvider(e,t){return l.INSTANCE.overrideProvider(e,t)}static inject(e,t,n){return l.INSTANCE.inject(e,t,(0,r.\u0275convertToBitFlags)(n))}static get(e,t=r.Injector.THROW_IF_NOT_FOUND,n=r.InjectFlags.Default){return l.INSTANCE.inject(e,t,n)}static runInInjectionContext(e){return l.INSTANCE.runInInjectionContext(e)}static createComponent(e){return l.INSTANCE.createComponent(e)}static resetTestingModule(){return l.INSTANCE.resetTestingModule()}static execute(e,t,n){return l.INSTANCE.execute(e,t,n)}static get platform(){return l.INSTANCE.platform}static get ngModule(){return l.INSTANCE.ngModule}static flushEffects(){return l.INSTANCE.flushEffects()}initTestEnvironment(e,t,n){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");l._environmentTeardownOptions=n?.teardown,l._environmentErrorOnUnknownElementsOption=n?.errorOnUnknownElements,l._environmentErrorOnUnknownPropertiesOption=n?.errorOnUnknownProperties,this.platform=t,this.ngModule=e,this._compiler=new L(this.platform,this.ngModule),(0,r.\u0275setAllowDuplicateNgModuleIdsForTest)(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,l._environmentTeardownOptions=void 0,(0,r.\u0275setAllowDuplicateNgModuleIdsForTest)(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,r.\u0275resetCompiledComponents)(),this._compiler!==null&&this.compiler.restoreOriginalState(),this._compiler=new L(this.platform,this.ngModule),(0,r.\u0275setUnknownElementStrictMode)(this._previousErrorOnUnknownElementsOption??b),(0,r.\u0275setUnknownPropertyStrictMode)(this._previousErrorOnUnknownPropertiesOption??j);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0,this._instanceDeferBlockBehavior=_}}return this}configureCompiler(e){if(e.useJit!=null)throw new Error("JIT compiler is not configurable via TestBed APIs.");return e.providers!==void 0&&this.compiler.setCompilerProviders(e.providers),this}configureTestingModule(e){return this.assertNotInstantiated("TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=e.teardown,this._instanceErrorOnUnknownElementsOption=e.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=e.errorOnUnknownProperties,this._instanceDeferBlockBehavior=e.deferBlockBehavior??_,this._previousErrorOnUnknownElementsOption=(0,r.\u0275getUnknownElementStrictMode)(),(0,r.\u0275setUnknownElementStrictMode)(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,r.\u0275getUnknownPropertyStrictMode)(),(0,r.\u0275setUnknownPropertyStrictMode)(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(e),this}compileComponents(){return this.compiler.compileComponents()}inject(e,t,n){if(e===V)return this;const o={},i=this.testModuleRef.injector.get(e,o,(0,r.\u0275convertToBitFlags)(n));return i===o?this.compiler.injector.get(e,t,n):i}get(e,t=r.Injector.THROW_IF_NOT_FOUND,n=r.InjectFlags.Default){return this.inject(e,t,n)}runInInjectionContext(e){return(0,r.runInInjectionContext)(this.inject(r.EnvironmentInjector),e)}execute(e,t,n){const o=e.map(i=>this.inject(i));return t.apply(n,o)}overrideModule(e,t){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(e,t),this}overrideComponent(e,t){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(e,t),this}overrideTemplateUsingTestingModule(e,t){return this.assertNotInstantiated("TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(e,t),this}overrideDirective(e,t){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(e,t),this}overridePipe(e,t){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(e,t),this}overrideProvider(e,t){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(e,t),this}overrideTemplate(e,t){return this.overrideComponent(e,{set:{template:t,templateUrl:null}})}createComponent(e){const t=this.inject(D),n=`root${Ae++}`;if(t.insertRootElement(n),(0,r.\u0275getAsyncClassMetadataFn)(e))throw new Error(`Component '${e.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);const o=e.\u0275cmp;if(!o)throw new Error(`It looks like '${(0,r.\u0275stringify)(e)}' has not been compiled.`);const i=new r.\u0275Render3ComponentFactory(o),a=()=>{const Q=i.create(r.Injector.NULL,[],`#${n}`,this.testModuleRef);return this.runInInjectionContext(()=>{const H=this.inject(r.\u0275ChangeDetectionScheduler,null)!==null?new re(Q):new oe(Q);return H.initialize(),H})},u=this.inject(N,!1)?null:this.inject(r.NgZone,null),g=u?u.run(a):a();return this._activeFixtures.push(g),g}get compiler(){if(this._compiler===null)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return this._testModuleRef===null&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(e,t){if(this._testModuleRef!==null)throw new Error(`Cannot ${t} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${e}\`.`)}checkGlobalCompilationFinished(){!this.globalCompilationChecked&&this._testModuleRef===null&&(0,r.\u0275flushModuleScopingQueueAsMuchAsPossible)(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let e=0;if(this._activeFixtures.forEach(t=>{try{t.destroy()}catch(n){e++,console.error("Error during cleanup of component",{component:t.componentInstance,stacktrace:n})}}),this._activeFixtures=[],e>0&&this.shouldRethrowTeardownErrors())throw Error(`${e} ${e===1?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const e=this._instanceTeardownOptions,t=l._environmentTeardownOptions;return!e&&!t?I:e?.rethrowErrors??t?.rethrowErrors??this.shouldTearDownTestingModule()}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??l._environmentErrorOnUnknownElementsOption??b}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??l._environmentErrorOnUnknownPropertiesOption??j}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??l._environmentTeardownOptions?.destroyAfterEach??I}getDeferBlockBehavior(){return this._instanceDeferBlockBehavior}tearDownTestingModule(){if(this._testModuleRef===null)return;const e=this.inject(D);try{this._testModuleRef.destroy()}catch(t){if(this.shouldRethrowTeardownErrors())throw t;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:t})}finally{e.removeAllRootElements?.()}}flushEffects(){this.inject(r.\u0275EffectScheduler).flush()}}const V=l;function $(s,e){const t=l.INSTANCE;return function(){return t.execute(s,e,this)}}class z{constructor(e){this._moduleDef=e}_addModule(){const e=this._moduleDef();e&&l.configureTestingModule(e)}inject(e,t){const n=this;return function(){return n._addModule(),$(e,t).call(this)}}}function Pe(s,e){return e?function(){const t=l.INSTANCE;return s&&t.configureTestingModule(s),e.apply(this)}:new z(()=>s)}globalThis.beforeEach?.(K(!1)),globalThis.afterEach?.(K(!0));function K(s){return()=>{const e=l.INSTANCE;e.shouldTearDownTestingModule()===s&&(e.resetTestingModule(),ie())}}const ke=""}}]);
